\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}
\usepackage{longtable}
\usepackage{float}
\usepackage{soul}
\usepackage{xcolor}
\usepackage{ulem}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{SE 3XA3: Module Interface Specification\\Super Refactored Mario Python}

\author{203, Abstract Connoisseurs 
		\\ David Jandric, jandricd
		\\ Daniel Noorduyn, noorduyd
		\\ Alexander Samaha, samahaa
}

\date{\today}

\begin {document}

\maketitle

\newpage

\section*{Entity Base Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Vector2D & &\\
    pygame.Rect & // & Class for representing a rectangle\\
    \textcolor{red}{pygame.sprite.Sprite} & \textcolor{red}{//} & \textcolor{red}{Class for representing a sprite}\\
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new EntityBase & $\mathbb{Z, Z, R}$ & EntityBase & ---\\
\hline
apply\_gravity & --- & --- & ---\\
\hline
update\_traits & --- & --- & ---\\
\hline
get\_pos\_index & --- & Vector2D & ---\\
\hline
get\_float\_pos\_index & --- & Vector2D & ---\\
\hline
\color{red}set\_points\_text\_start\_position & \color{red}$\mathbb{R, R}$ & \color{red}--- & \color{red}---\\
\hline
\color{red}move\_points\_text\_up\_and\_draw & \color{red}Camera & \color{red}--- & \color{red}---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
vel: Vector2D & // & Represents velocity of the entity\\
rect: Rect & // & Represents the rectangle the entity is encased in\\
gravity: $\mathbb{R}$ & // & Represents the gravitational acceleration of the entity\\
traits: List[Trait] & // & List of traits the entity has\\
alive: $\mathbb{B}$ & // & Self explanatory\\
time\_after\_death: $\mathbb{R}$ & // & Represents the time after an entity has died\\
timer: $\mathbb{N}$ & // & Keeps track of the number of time the entity has been updated\\
type: string & // & Represents the name of the type of entity\\
on\_ground: $\mathbb{B}$ & // & Self explanatory\\
obey\_gravity: $\mathbb{B}$ & // & Self explanatory\\
\color{red}text\_pos: Vector2D & \color{red}// & \color{red}Text position to show points when dying\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new EntityBase(x, y, gravity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item vel, rect, gravity := Vector2D(0, 0), Rect(x * 32, y * 32, 32, 32)\textcolor{red}{, gravity}
        \item traits, alive, on\_ground, obey\_gravity := None, True, False, True
        \item timer\_after\_death, timer, type := 5, 0, ""
        \item \color{red}text\_pos := Vector2D(x, y)
    \end{itemize}
    \item output: $out := self$
\end{itemize}

\noindent apply\_gravity():
\begin{itemize}
    \item transition: \\\\
    \begin{tabular}{|l|l|}
    \hline
        obey\_gravity & \begin{tabular}{l}
            $\lnot$ on\_ground $\Rightarrow$ vel := vel + Vector2D(0, gravity) \\
            \hline
            on\_ground $\Rightarrow$ vel.set\_y(0)\\
            \hline
        \end{tabular}\\
    \hline
    \end{tabular}
\end{itemize}

\noindent update\_traits():
\begin{itemize}
    \item transition: If there are traits, then update all traits using trait.update()
\end{itemize}

\noindent get\_pos\_index():
\begin{itemize}
    \item output: $out := $ Vector2D(int(rect.x / 32), int(rect.y / 32))
\end{itemize}

\noindent get\_float\_pos\_index():
\begin{itemize}
    \item output: $out := $ Vector2D(rect.x / 32, rect.y / 32)
\end{itemize}

\noindent \textcolor{red}{set\_points\_text\_start\_position(x, y):}
\begin{itemize}
    \item \textcolor{red}{transition: text\_pos := Vector2D(x, y)}
\end{itemize}

\noindent \textcolor{red}{move\_points\_text\_up\_and\_draw(camera):}
\begin{itemize}
    \item \textcolor{red}{transition: text\_pos += Vector2D(-0.5, 0)}
    \item \textcolor{red}{output: draw the points text at (text\_pos.get\_x() + camera.x, text\_pos.get\_y())}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Goomba Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    \color{red}LeftRightWalkTrait & &\\
    \color{red}BounceTrait & &\\ 
    Camera & & \\
    EntityBase & & \\
    Level & & \\
    pygame.Surface & & \\
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Goomba & \begin{tabular}{l}
   \st{Surface, Map[string: Surface $|$ Animation],} \\
    $\mathbb{R, R}$, Level 
\end{tabular}& \st{entity\_base}\textcolor{red}{Goomba}& ---\\
\hline
update & Camera & --- & ---\\
\hline
draw\_goomba & Camera & --- & ---\\
\hline
on\_dead & Camera & --- & ---\\
\hline
draw\_flat\_goomba & Camera & --- & ---\\
\hline
\textcolor{red}{bounce} & \color{red}--- & \color{red}--- & \color{red}---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
\st{sprite\_collection: Map[string: Surface | Animation]} & \st{//} & \st{Collection of all sprites}\\
animation: Animation & // & 
    \begin{tabular}{l}
        Represents the images\\
        related to Koopa animation\\
    \end{tabular}\\
\st{screen: Surface} & \st{//} & \st{Represents the entire screen}\\
type: string & // & The type of the entity\\
\st{dashboard: Dashboard} & \st{//} & \st{Represents the dashboard}\\
\color{red}left\_right\_trait: LeftRightWalkTrait & \color{red}// & 
    \begin{tabular}{l}
        \color{red}Variable holding LeftRightWalkTrait\\
        \color{red}to handle Goomba movement
    \end{tabular}\\
\color{red}in\_air: $\mathbb{B}$ & \color{red}// & \color{red}Self explanatory
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Goomba(\st{screen, sprite\_coll,} x, y, level):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item \st{sprite\_collection := sprite\_coll}
        \item animation := A new animation object, initialized with the images related to the Goomba
        \item \st{screen, type, dashboard := screen, "Mob", level.dashboard}
        \item \color{red}left\_right\_trait := LeftRightWalkTrait(self, level)
        \item \color{red}type := "Mob"
        \item \color{red}traits := List containing an initialized BounceTrait
        \item \color{red}in\_air := False
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update(camera):
\begin{itemize}
    \item \st{transition: If the Goomba is alive, then apply gravity (using apply\_gravity()) and draw the Goomba (using draw\_goomba(camera)). If the Goomba is dead, then call on\_dead(camera)}.
    \item \color{red}Update traits (using self.update\_traits()), then apply gravity (using self.apply\_gravity()). If the Goomba is alive, then draw the Goomba (using draw\_goomba(camera)) and update left\_right\_trait (using self.left\_right\_trait.update(). If the Goomba is dead, then call on\_dead(camera).
\end{itemize}

draw\_goomba(camera):
\begin{itemize}
    \item transition: screen.blit(animation.image, (rect.x + camera.x, rect.y)), animation.update()
\end{itemize}

on\_dead(camera):
\begin{itemize}
    \item transition: When killed, the Goomba will draw a string representing the number of points given by killing the Goomba, and also replace the regular animation images of the Goomba with the flat image. Then, after \st{one cycle of this} \textcolor{red}{time\_after\_death cycles}, it will set the alive attribute to None, deleting the Goomba.
\end{itemize}

draw\_flat\_goomba(camera):
\begin{itemize}
    \item transition: Draws the flat Goomba to the screen.
\end{itemize}

\textcolor{red}{bounce():}
\begin{itemize}
    \item \color{red}transition: traits["BounceTrait"].jump = True
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Koopa Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    Camera & & \\
    EntityBase & & \\
    \color{red}EntityCollider & & \\
    Level & & \\
    pygame.Surface & & \\
    \color{red}LeftRightWalkTrait & & \\
    \color{red}BounceTrait & & \\
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Koopa & \begin{tabular}{l}
    \st{Surface, Map[string: Surface $|$ Animation],}\\
     $\mathbb{R, R}$, Level
\end{tabular} & Koopa & ---\\
\hline
update & Camera & --- & ---\\
\hline
draw\_koopa & Camera & --- & ---\\
\hline
shell\_bouncing & Camera & --- & ---\\
\hline
\color{red}check\_entity\_collision & \color{red}--- & \color{red}--- & \color{red}---\\
\hline
die & Camera & --- & ---\\
\hline
\color{red}bounce & \color{red}--- & \color{red}--- & \color{red}---\\
\hline
sleeping\_in\_shell & Camera & --- & ---\\
\hline
update\_alive & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
\st{sprite\_collection: Map[string: Surface | Animation]} & \st{//} & \st{Collection of all sprites}\\
animation: Animation & // & Represents the images related to Koopa animation\\
\st{screen: Surface} & \st{//} & \st{Represents the entire screen}\\
type: string & // & The type of the entity\\
\st{dashboard: Dashboard} & \st{//} & \st{Represents the dashboard}\\
\color{red}left\_right\_trait: LeftRightWalkTrait & \color{red} //& \color{red}Same as Goomba\\
\color{red}entity\_collider: EntityCollider & \color{red} //& \color{red}Used for checking collision with entities\\
\color{red}in\_air& \color{red} //& \color{red}Same as Goomba\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Koopa(\st{screen, sprite\_coll, }x, y, level):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item \st{sprite\_collection := sprite\_coll}
        \item animation := A new animation object, initialized with the images related to the Koopa
        \item \st{screen, type, dashboard := screen, "Mob", level.dashboard}
        \item \color{red} time\_after\_death, type, level\_obj := 35, "Mob", level
        \item \color{red} entity\_collider, in\_air := EntityCollider(self), False
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update(camera):
\begin{itemize}
    \item transition: If the Koopa is alive, then call update\_alive(camera). If the Koopa is sleeping, then call update\_sleeping(camera). If the Koopa is in it's shell bouncing state, call shell\_bouncing(camera). If the Koopa is dead, then call die(camera)
\end{itemize}

draw\_koopa(camera):
\begin{itemize}
    \item transition: Draw the Koopa on the screen, using previously mentioned methods.
\end{itemize}

shell\_bouncing(camera):
\begin{itemize}
    \item transition: When the Koopa is in this state, it will bounce back and forth, and obey gravity. The animation image of the Koopa is set to the hiding image, then draw\_koopa(camera) is called.
\end{itemize}

die(camera):
\begin{itemize}
    \item transition: When Koopa is killed, display the points on the screen, and draw the hiding Koopa. After 500 frames, the Koopa is deleted by setting alive := None
\end{itemize}

sleeping\_in\_shell(camera):
\begin{itemize}
    \item transition: If the timer $<$ time\_after\_death , then draw the Koopa hiding image. Otherwise, set alive, timer := True, 0. Then, increment timer.
\end{itemize}

update\_alive(camera):
\begin{itemize}
    \item transition: Call apply\_gravity, draw\_koopa(camera), animation.update()
\end{itemize}

\textcolor{red}{check\_entity\_collision():}
\begin{itemize}
    \item \color{red}transition: Check all entities in the level, and if they are colliding and the Koopa is bouncing, then kill the other entity.
\end{itemize}

\textcolor{red}{bounce():}
\begin{itemize}
    \item \color{red}transition: traits["BounceTrait"].jump = True
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Mario Module}
\subsection*{Module}
\subsection*{Uses}
Uses entity\_base
\subsection*{Syntax}
\subsubsection*{Exported Constants}
None
\subsubsection*{Exported Access Programs}
\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Mario & $\mathbb{N}, \mathbb{N}$, Level, Screen, Dashboard, $\mathbb{R}$ & Mario & \\
\hline
get\_pos & & $\mathbb{N}, \mathbb{N}$ &\\
\hline
set\_pos & $\mathbb{N}, \mathbb{N}$ & & TypeError\\
\hline
update & & &\\
\hline
\textcolor{red}{draw\_mario} & & &\\
\hline
move\_mario & & & \\
\hline
check\_entity\_collision & & &\\
\hline
on\_collision\_with\_item & Item & & TypeError\\
\hline
on\_collision\_with\_block & random\_block & & TypeError\\
\hline
on\_collision\_with\_mob & entity\_base, collision\_state & & TypeError\\
\hline
\textcolor{red}{on\_collision\_with\_mushroom} & \textcolor{red}{Item} & & \textcolor{red}{TypeError}\\
\hline
\textcolor{red}{on\_collision\_with\_power\_block} & \textcolor{red}{Item} & & \textcolor{red}{TypeError}\\
\hline
\textcolor{red}{small\_mario} & & & \\
\hline
\textcolor{red}{big\_mario} & & & \\
\hline
bounce & & &\\
\hline
kill\_entity & entity\_base & & TypeError\\
\hline
\textcolor{red}{next\_level} & & & \\
\hline
game\_over & & &\\
\hline
\st{get\_lives} & & $\mathbb{N}$ &\\
\hline
\end{tabular}

\subsection*{Semantics}
\subsubsection*{State Variables}
\st{sprite\_collection: Object of type Sprites}\\
camera: Object of type Camera\\
input: Object of type Input\\
in\_air: $\mathbb{B}$\\
in\_jump: $\mathbb{B}$\\
animation: Object of type Animation\\
traits: Seq of Traits\\
level\_obj: Object of type Level\\
collision: Object of type Collider\\
screen: Object of type Display\\
entity\_collider: Object of type EntityCollider\\
dashboard: Object of type Dashboard\\
restart: $\mathbb{B}$\\
pause: $\mathbb{B}$\\
pause\_obj: Object of type Pause\\
lives: $\mathbb{N}$\\
\textcolor{red}{big\_size: $\mathbb{B}$}\\
\textcolor{red}{timer: $\mathbb{N}$}\\
\textcolor{red}{next: $\mathbb{B}$}\\

\subsubsection*{State Invariant}
None

\subsubsection*{Assumptions \& Design Decisions}

\begin{itemize}
    \item The Mario constructor is called before any other access routines are called. Once called, the constructor will then not be used again.
\end{itemize}

\subsubsection*{Access Routine Semantics}
new Mario(x, y, level, screen, dashboard, gravity):
\begin{itemize}
    \item transition: \st{sprite\_collection = Sprites().sprite\_collection}\\
camera = new Camera(rect, self)\\
input = new Input(self)\\
in\_air = False\\
in\_jump = False\\
animation = new Animation(Seq of sprite\_collection)\\
traits = \textcolor{red}{\{ jump\_trait, bounce\_trait, go\_trait \}}\\
level\_obj = level\\
collision = Collider(self)\\
screen = screen\\
EntityCollider = EntityCollider(self)\\
dashboard = dashboard\\
restart = False\\
pause = False\\
pause\_obj = Pause(screen, self, dashboard)\\
lives = $\mathbb{N}$\\
\textcolor{red}{big\_size: False}\\
\textcolor{red}{timer: 120}\\
\textcolor{red}{next: False}\\\textbf{}
\end{itemize}

update():
\begin{itemize}
    \item transition: updates the following functions update\_traits, draw\_mario move\_mario, camera, apply\_gravity, check\_entity\_collision, check\_for\_input and game\_over if time == 0.
    \item exception: None
\end{itemize}

\textcolor{red}{draw\_mario():}
\begin{itemize}
    \item transition: x, y := x + vel.get\_x, y + vel.get\_y
    \item exception: None
\end{itemize}

move\_mario():
\begin{itemize}
    \item transition: x, y := x + vel.get\_x, y + vel.get\_y
    \item exception: None
\end{itemize}

check\_entity\_on\_collision():
\begin{itemize}
    \item transition: Checks if Mario collided with either of Item, Block, Mob entity, \textcolor{red}{power-up block or mushroom} and redirects to appropriate function.
    \item exception: None
\end{itemize}

\textcolor{red}{on\_collision\_with\_mushroom(item):}
\begin{itemize}
    \item transition: big\_size == True $\Rightarrow$ big\_mario()\\
    increments dashboard.points by 100 and dashboard.coins by 1. mushroom is set to dead.
    \item exception: TypeError if item is not of type Item
\end{itemize}

\textcolor{red}{on\_collision\_with\_mushroom(box):}
\begin{itemize}
    \item transition: $\lnot$ box.triggered $\Rightarrow$ add\_mushroom(box.x, box.y); box.triggered := True\\
    removes the box from the list of entities, sets box to triggered
    \item exception: TypeError if item is not of type Item
\end{itemize}

on\_collision\_with\_item(item):
\begin{itemize}
    \item transition: Collided item is removed from list of current items, dashboard.points increased by 100, dashboard.coins increased by 1.
    \item exception: TypeError if item is not of type Item
\end{itemize}

on\_collision\_with\_block(block):
\begin{itemize}
    \item transition: Collided item is removed from list of current items, dashboard.points increased by 100, dashboard.coins increased by 1.
    \item exception: TypeError if block is not of type RandomBlock
\end{itemize}

on\_collision\_with\_mob(mob, is\_colliding, is\_top):
\begin{itemize}
    \item \textcolor{red}{transition: if is\_top and is\_colliding == True $\Rightarrow$ bounce() and mob.alive := "sleeping" and mob.hit\_once := True\\
    if is\_top and mob.alive == "shell\_bouncing" $\Rightarrow$ bounce() and mob.alive := "sleeping" and mob.hit\_once := True\\
    if is\_top and mob.alive == "sleeping" $\Rightarrow$ bounce() and (if mob.rect.x < self.rect.x $\Rightarrow$ left\_right\_trait.direction = -1 and mob.rect.x += -5 else $\Rightarrow$ mob.rect.x += 5 and left\_right\_trait.direction = 1) and mob.alive := "sleeping" and mob.hit\_once == True\\
    if is\_colliding and mob.alive == "sleeping" $\Rightarrow$ (if mob.rect.x < self.rect.x $\Rightarrow$ left\_right\_trait.direction = -1 and mob.rect.x += -5 else $\Rightarrow$ mob.rect.x += 5 and left\_right\_trait.direction = 1)\\
    if mob.alive and is\_colliding and self.timer $>$ 120 $\Rightarrow$ (if big\_size $\Rightarrow$ small\_mario() else $\Rightarrow$ game\_over())}
    \item \textcolor{red}{exception: TypeError if mob is not of type entity\_base}
\end{itemize}

\color{red}
\textcolor{red}{small\_size():}
\begin{itemize}
    \item \textcolor{red}{transition: big\_size := False\\
    timer := 0\\
    animation := new Animation(Seq of sprite\_collection)\\
    traits[go\_trait].animation := animation\\
    img := animation.get\_image()
    rect.x := img.get\_width()
    rect.h := img.get\_height()
    rect.y += 32} 
    \item exception: None
\end{itemize}

big\_mario():
\begin{itemize}
    \item transition: big\_size := True\\
    animation := Animation(Seq of sprite\_collection)\\
    img = animation.get\_image()\\
    rect.w := img.get\_width()\\
    rect.h := img.get\_height()\\
    rect.y -= 32
    traits[go\_trait].animation = animation
    \item exception: None
\end{itemize}

\color{black}

bounce():
\begin{itemize}
    \item transition: traits["BounceTrait"].jump := True
    \item exception: None
\end{itemize}

kill\_entity(ent):
\begin{itemize}
    \item transition: If the entity is not a Koopa, then ent.alive := False, otherwise ent.alive := "sleeping". \\
    \color{red}
    dashboard.points += 100\\
    dashboard.earned\_points += 100\\
    \color{black}
    \item TypeError if ent is not of type entity\_base
\end{itemize}

game\_over():
\begin{itemize}
    \item transition: The screen is filled with black excluding a small circle around the player character. self.restart := True.\\
    \color{red}
    lives -= 1\\
    coins := 0\\
    dashboard.points -= dashboard.earned\_points\\
    dashboard.earned\_points := 0\\
    if lives == 0 $\Rightarrow$ restart := True $\land$ dashboard.points := 0\\
    else $\Rightarrow$ dashboard.state := "start" $\land$ dashboard.time := 420 $\land$ small\_mario() $\land$ timer := 120 $\land$ dashboard.lives := lives $\land$ rect.x, rect.y := 0, 0 $\land$ camera.pos := Vector2D(rect.x, rect.y)
    \color{black}
    \item exception: None
\end{itemize}

\color{red}
next\_level():
\begin{itemize}
    \item transition: rect.x := 0\\
    rect.y := 0
    camera.pos := Vector2D(rect.x, rect.y)\\
    camera.level\_length = Level.level\_length
    \item exception: None
\end{itemize}
\color{black}

get\_pos():
\begin{itemize}
    \item output: camera.x + rect.x, y
    \item exception: None
\end{itemize}

set\_pos(x, y):
\begin{itemize}
    \item transition: rect.x, rect.y = x, y
    \item exception: TypeError if x, y are not of type Integer.
\end{itemize}

\st{get\_lives():}
\begin{itemize}
    \item output: out := self.lives
    \item exception: None
\end{itemize}

\st{death\_in\_game():}
\begin{itemize}
    \item transition: if self.lives != 0 $\Rightarrow$ self.restart, lives := True, lives - 1 \emph{//If lives are not zero, then restart level.}\\
    else call game\_over()
    \item exception: None
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None

\newpage

\section*{Camera Module}
\subsection*{Uses}
None
\subsection*{Syntax}
\subsubsection*{Exported Constants}
None
\subsubsection*{Exported Access Programs}
\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Camera & Vector2D, $\mathbb{N}$, Entity, $\mathbb{N}$ & Camera & \\
\hline
move & & &\\
\hline
\end{tabular}

\subsection*{Semantics}
\subsubsection*{State Variables}
pos: Object of type Vector2D \emph{Contains the coordinates for camera position.}\\ 
entity: Object of type Entity\\
x: $\mathbb{N}$\\ 
y: $\mathbb{N}$\\
\textcolor{red}{last\_pos: $\mathbb{N}$}\\
\textcolor{red}{level\_length = $\mathbb{N}$}\\

\subsubsection*{State Invariant}
None
\subsubsection*{Assumptions \& Design Decisions}
\begin{itemize}
    \item The Camera Constructor is called before any other access routines are called. Once called, the constructor will then not be called upon again.
\end{itemize}

\subsubsection*{Access Routine Semantics}

new Camera(pos, entity):
\begin{itemize}
    \item transition: \\self.pos := Vector2D(pos.x, pos.y)\\
                      self.entity := entity\\
                      self.x := pos.get\_x()\\
                      self.y := pos.get\_y()\\
                      \textcolor{red}{last\_pos = pos.get\_x()}\\
                        \textcolor{red}{level\_length = level\_length}\\
    \item exception: None
\end{itemize}

move():

\begin{itemize}
\item \st{transition}: x\_pos\_float := entity.get\_pos\_index\_as\_float().get\_x().\\ 
    if $10 < \text{x\_pos\_float} < 50 \Rightarrow$ pos := Vector2D(x\_pos\_float + 10, pos.get\_y())\\
    \item \textcolor{red}{transition}: x\_pos\_float := entity.get\_pos\_index\_as\_float().get\_x().\\ 
    if $10 < \text{x\_pos\_float} <$ level\_length - 10) $\land$ (-x\_pos\_float + 10) $<$ last\_pos $\Rightarrow$ pos := Vector2D(x\_pos\_float + 10, pos.get\_y())\\
    x := pos.get\_x() * 32\\
    y := pos.get\_y() * 32
    \item exception None
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None

\newpage

\section*{Level Module}
\subsection*{Uses}
None
\subsection*{Syntax}
\subsubsection*{Exported Constants}
None
\subsubsection*{Exported Access Programs}
\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Level & \st{Screen, Dashboard} & Level & \\
\hline
load\_level & String & --- & FileNotFoundError\\
\hline
load\_entities & JSON & --- & --- \\
\hline
load\_layers & JSON & --- & --- \\
\hline
load\_objects & JSON & --- & --- \\
\hline
update\_entities & Camera & ---  & --- \\
\hline
draw\_level & Camera & --- & IndexError\\
\hline
add\_cloud\_sprite & $\mathbb{N}, \mathbb{N}$ & ---  & IndexError\\
\hline
add\_pipe\_sprite  & $\mathbb{N}, \mathbb{N}, \mathbb{N}$ & ---  & IndexError\\
\hline
add\_bush\_sprite & $\mathbb{N}, \mathbb{N}$ & ---  & IndexError\\
\hline
add\_random\_box & $\mathbb{N}, \mathbb{N}$ & --- & \\
\hline
add\_coin & $\mathbb{N}, \mathbb{N}$ & --- &\\
\hline
add\_goomba & $\mathbb{N}, \mathbb{N}$ & --- &\\
\hline
add\_koopa & $\mathbb{N}, \mathbb{N}$ & --- &\\
\hline
\color{red}add\_power\_box & \color{red}$\mathbb{N}, \mathbb{N}$ & \color{red}--- &\\
\hline
\end{tabular}

\subsection*{Semantics}
\subsubsection*{State Variables}
\st{sprites: Object of type Sprite\\
dashboard: Object of type Dashboard\\
screen: Object of type Screen}\\
level: \st{Object of type Level}\textcolor{red}{Seq of Tile}\\
level\_length: $\mathbb{N}$\\
entity\_list: Seq of Entity

\subsubsection*{State Invariant}
None
\subsubsection*{Assumptions \& Design Decisions}
\begin{itemize}
    \item The Level constructor is called before any other access routines are called. Once called, the constructor will then not be called upon again.
\end{itemize}

\subsubsection*{Access Routine Semantics}
new Level(screen, dashboard):
\begin{itemize}
    \item transition:\\
    \st{sprites := sprites()\\
    dashboard := dashboard\\
    screen := screen}\\
    level := \st{None}\textcolor{red}{[]}\\
    level\_length := 0\\
    entity\_list := []\\
    \item exception: None
\end{itemize}

load\_level(levelname):
\begin{itemize}
    \item transition: \\
    data := open(levelname) as json\_data $\Rightarrow$ json.load(json\_data)\\ 
    Call load\_layers(data)\\
    Call load\_objects(data)\\
    Call load\_entities(data)\\
    level\_length := data["length"]
    \item exception: FileNotFoundError triggered if file is not found.
\end{itemize}

load\_entities(data):
\begin{itemize}
    \item transition: \\
\begin{tabular}{|p{3cm}|l|}
\hhline{|-|-|}
$c = \mbox{random\_box}$ & add\_random\_box(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
$c = \mbox{goomba}$ & add\_goomba(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
$c = \mbox{koopa}$ & add\_koopa(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
$c = \mbox{coin}$ & add\_coin \_box(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
\color{red}$c = \mbox{power\_box}$ & \color{red}add\_power\_box(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
\end{tabular}
    \item exception: None
\end{itemize}

load\_layers(data):
\begin{itemize}
    \item transition:\\
    layers := [ ]  //\emph{Initializes an empty sequence}\\
    $\forall x \in data["level"]["layers"]["sky"]["x"] \mid (\forall y \in data["level"]["layers"]["sky"]["y"]$ : \text{layers + Tile(sprites.sprite\_collection.get("sky"), None))}\\
    $\forall x \in data["level"]["layers"]["ground"]["x"] \mid (\forall y \in data["level"]["layers"]["ground"]["y"]$ : \text{layers + Tile(sprites.sprite\_collection.get("ground"), None))}\\
    //\emph{This is initializing the sky and ground blocks and appending them to a layer sequence.}
    \item exception: None
\end{itemize}

load\_objects(data):
\begin{itemize}
    \item transition: \\
    \begin{tabular}{|p{3cm}|l|}
\hhline{|-|-|}
$i = \mbox{bush}$ & add\_bush\_sprite(x, y) $\Rightarrow \forall x, y \in data["level"]["objects"][c]$\\
\hhline{|-|-|}
$i = \mbox{cloud}$ & add\_cloud\_sprite(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
$i = \mbox{pipe}$ & add\_pipe\_sprite(x, y) $\Rightarrow \forall x, y \in data["level"]["entities"][c]$\\
\hhline{|-|-|}
\end{tabular}
    \item exception: None
\end{itemize}

update\_entities(cam): 
\begin{itemize}
    \item transition: $\forall\ \text{entity} \in \text{entity\_list} : \text{entity.update(cam)}$ $\land$ \textcolor{red}{(entity.alive = None $\Rightarrow$ entity\_list.remove(entity))}\\
\begin{tabular}{|p{3cm}|l|}
\hhline{|-|-|}
\st{$\mbox{entity.alive}$} & None\\
\hhline{|-|-|}
\st{$\lnot \mbox{entity.alive}$} & entity\_list.remove(entity)\\
\hhline{|-|-|}
\end{tabular}
    \item exception: None
\end{itemize}

draw\_level(camera):
\begin{itemize}
    \item transition: $\forall\ y \in [$0 .. 15$] : \forall\ x \in [0 - \text{camera.pos.get\_x()} + 1$ .. $20 - \text{camera.pos.get\_x()} -1]$ . \textcolor{red}{\_draw\_sprite(level[y][x], x, y)}\\
\begin{table}[H]
\begin{tabular}{lllll}
\cline{1-3}
\multicolumn{1}{|l|}{\multirow{8}{*}{\st{level{[}y{]}{[}x{]}.sprite}}} & \multicolumn{1}{l|}{\multirow{5}{*}{level{[}y{]}{[}x{]}.sprite.redraw\_background}} & \multicolumn{1}{l|}{\multirow{5}{*}{\begin{tabular}[c]{@{}l@{}}screen.blit(sprite\_collection.get("sky").image, (x \\ + camera.pos.get\_x()) * 32, y * 32)\\ $\land$ level{[}y{]}{[}x{]}.sprite.draw\_sprite(x \\ + camera.pos.get(x), y, screen)) \\ $\land$ update\_entities(camera)\end{tabular}}} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\ \cline{2-3}
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{\multirow{3}{*}{$\lnot$level{[}y{]}{[}x{]}.sprite.redraw\_background}} & \multicolumn{1}{l|}{\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}level{[}y{]}{[}x{]}.sprite.draw\_sprite(x \\ + camera.pos.get(x), y, screen) \\ $\land$ update\_entities(camera)\end{tabular}}} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\
\multicolumn{1}{|l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & & \\ \cline{1-3}
\multicolumn{1}{|l|}{\st{$\lnot$level{[}y{]}{[}x{]}.sprite}} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{update\_entities(camera)} & & \\ \cline{1-3}
& & & & \\
& & & & \\
& & & & \\
& & & &
\end{tabular}
\end{table}
    \item exception: IndexError if x, y are out of range.
\end{itemize}

add\_cloud\_sprite(x, y):
\begin{itemize}
    \item transition: $\forall\ \text{y\_off} \in [0 .. 2] : (\forall\ \text{x\_off} \in [0 .. 3]$ : level[y + y\_off][x + x\_off] = Tile(sprites.sprite\_collection.get("cloud", None))
    \item exception: IndexError if x, y are out of range.
\end{itemize}

add\_pipe\_sprite(x, y, length):
\begin{itemize}
    \item transition:\\ length := 2\\
    level[y][x] = Tile(sprites.sprite\_collection.get("pipeL"), pygame.Rect(x * 32, y * 32, 32, 32))\\
    level[y][x] = Tile(sprites.sprite\_collection.get("pipeR"), pygame.Rect(x * 32, y * 32, 32, 32))\\
    $\forall\ i \in (1, length + 20) : $ level[y + i][x] = Tile(sprites.sprite\_collection.get("pipe2L"), pygame.Rect(x * 32, (y + i) * 32, 32, 32))\\
    $\forall\ i \in (1, length + 20) : $ level[y + i][x + 1] = Tile(sprites.sprite\_collection.get("pipe2R"), pygame.Rect((x + 1) * 32, (y + i) * 32, 32, 32))\\
    \item exception: IndexError if x, y are out of range.
\end{itemize}

add\_bush\_sprite(x, y):
\begin{itemize}
    \item transition: \\
    level[y][x] = Tile(sprites.sprite\_collection.get("bush\_1"), None)\\
    level[y][x+1] = Tile(sprites.sprite\_collection.get("bush\_2"), None)\\
    level[y][x+2] = Tile(sprites.sprite\_collection.get("bush\_3"), None)\\
    \item exception: IndexError if x, y are out of range.
\end{itemize}

add\_random\_box(x, y):
\begin{itemize}
    \item transition:\\ level[y][x] = Tile(None, pygame.Rect(x * 32, y * 32 - 1, 32, 32))\\
    entity\_list := entity\_list + $\langle$RandomBox(\st{screen, sprites.sprite\_collection,} x, y\st{, dashboard})$\rangle$
    \item exception: None
\end{itemize}

add\_coin(x, y):
\begin{itemize}
    \item transition: entity\_list := entity\_list + $\langle$Coin(\st{screen, sprites.sprite\_collection,} x, y)$\rangle$
    \item exception: None
\end{itemize}

add\_goomba(x, y):
\begin{itemize}
    \item transition: entity\_list := entity\_list +$\langle$Goomba(\st{screen, sprites.sprite\_collection, }x, y, self)$\rangle$
    \item exception: None
\end{itemize}

add\_koopa(x, y):
\begin{itemize}
    \item transition: entity\_list := entity\_list + $\langle$Koopa(\st{screen, sprites.sprite\_collection, }x, y, self)$\rangle$
    \item exception: None
\end{itemize}

\textcolor{red}{add\_power\_box(x, y):}
\begin{itemize}
    \item \color{red}transition:\\ level[y][x] = Tile(None, pygame.Rect(x * 32, y * 32 - 1, 32, 32))\\
    entity\_list := entity\_list + $\langle$PowerUpBox(x, y)$\rangle$
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Input Module}
\subsection*{Uses}
None
\subsection*{Syntax}\
\subsubsection*{Exported Constants}
None
\subsubsection*{Exported Types}
None
\subsubsection*{Exported Access Programs}
\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Input & Entity\_Base & Input & \\
\hline
check\_for\_input & & &\\
\hline
check\_for\_keyboard\_input & & &\\
\hline
check\_for\_quit\_and\_restart\_input\_events & & &\\
\hline
\end{tabular}

\subsection*{Semantics}
\subsubsection*{State Variables}
mouse\_X: $\mathbb{N}$\\
mouse\_Y: $\mathbb{N}$\\
entity: Object of type Entity\_Base\\

\subsubsection*{State Invariant}
None

\subsubsection*{Assumptions \& Design Decisions}
\begin{itemize}
    \item The Input constructor is called before any other access routines are called. Once called, the constructor will then not be called upon again.
\end{itemize}

\subsubsection*{Access Routine Semantics}
new Input(entity):
\begin{itemize}
    \item transition:\\
    mouse\_X := 0\\
    mouse\_Y := 0\\
    entity := entity
    \item exception: None
\end{itemize}

check\_for\_input():
\begin{itemize}
    \item transition: \\
    Call check\_for\_keyboard\_input()\\
    Call check\_for\_mouse\_input()\\
    check\_for\_quit\_and\_restart\_input\_events()\\
    \item exception: None
\end{itemize}

check\_for\_keyboard\_input():
\begin{itemize}
    \item transition:\\ pressed\_keys := pygame.key.get\_pressed()\\
    is\_jumping := pressed\_keys[K\_SPACE] $\lor$ pressed\_keys[K\_UP]\\
    entity.traits["jumpTrait"].jump(is\_Jumping)
    entity.traits["goTrait"].boost = pressed\_keys[L\_SHIFT]
    direction := entity.traits["goTrait"].direction\\
\begin{table}[H]
\begin{tabular}{lllll}
\cline{1-2}
\multicolumn{1}{|l|}{pressed\_keys{[}K\_LEFT{]} $\land\ \lnot$ pressed\_keys{[}K\_RIGHT{]}} & \multicolumn{1}{l|}{direction = -1} &  &  &  \\ \cline{1-2}
\multicolumn{1}{|l|}{pressed\_keys{[}K\_RIGHT{]} $\land\ \lnot$ pressed\_keys{[}K\_LEFT{]}} & \multicolumn{1}{l|}{direction = 1}  &  &  &  \\ \cline{1-2}
\multicolumn{1}{|l|}{else}                                                                  & \multicolumn{1}{l|}{direction = 0}  &  &  &  \\ \cline{1-2}
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  &  \\
                                                                                            &                                     &  &  & 
\end{tabular}
\end{table}
    \item exception: None
\end{itemize}

check\_for\_quit\_and\_restart\_input\_events():
\begin{itemize}
    \item transition: \\ events := pygame.event.get()\\
    $\forall\ \text{event} \in \text{events}$ | event.type == pygame.QUIT : pygame.quit() $\land$ sys.exit()\\
    
    $\forall\ \text{event} \in \text{events}$ | event.type == pygame.KEYDOWN $\land$ event.key == pygame.K\_ESCAPE : entity.pause := True $\land$ entity.pause\_obj.create\_background\_blur()
    \item exception: None
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Vector2D Module}

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

Vector2D = tuple of (x: float, y: float)

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Vector2D & $\mathbb{R, R}$ & Vector2D & TypeError\\
\hline
get\_x       & ---          & $\mathbb{R}$ & ---\\
\hline
get\_y       & ---          & $\mathbb{R}$ & ---\\
\hline
add          & Vector2D     & ---          & TypeError\\
\hline
set\_x       & $\mathbb{R}$ & ---          & TypeError\\
\hline
set\_y       & $\mathbb{R}$ & ---          & TypeError\\
\hline
mag          & ---          & $\mathbb{R}$ & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$x$: $\mathbb{R}$ // Represents the x component of the vector\\ 
$y$: $\mathbb{R}$ // Represents the y component of the vector

\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions \& Design Decisions}
None

\subsubsection* {Access Routine Semantics}

new Vector2D($x, y$):
\begin{itemize}
\item transition: $x, y := x, y$
\item output: $\mathit{out} := \mathit{self}$
\item exception: $x, y$ not of type $\mathbb{R} \Rightarrow$ TypeError.
\end{itemize}

\noindent get\_x():
\begin{itemize}
\item output: $out := x$
\end{itemize}

\noindent get\_y():
\begin{itemize}
\item output: $out := y$
\end{itemize}

\noindent add(v):
\begin{itemize}
\item transition: $x, y := x + v.get\_x(), y := y + v.get\_y()$
\item exception: $v$ is not of type Vector2D $\Rightarrow$ TypeError 
\end{itemize}

\noindent set\_x(x):
\begin{itemize}
\item transition: $x := x$
\item exception: $x$ is not of type $\mathbb{R} \Rightarrow$ TypeError
\end{itemize}

\noindent set\_y(y):
\begin{itemize}
\item transition: $y := y$
\item exception: $y$ is not of type $\mathbb{R} \Rightarrow$ TypeError
\end{itemize}

\noindent mag():
\begin{itemize}
\item output: $out := \sqrt{x^2 + y^2}$
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Sound\_Controller Module}

\subsection* {Uses}

\begin{tabular}{lll}
    pygame.mixer.Channel & // & Contains methods for controlling a sound channel\\
    pygame.mixer.Sound   & // & Contains methods for loading sounds from a file
\end{tabular}
\subsection* {Syntax}

\subsubsection* {Exported Types}

N/A

\subsubsection* {Exported Constants}

\begin{tabular}{lll}
    SOUNDTRACK   & = & Main soundtrack\\
    \color{red}HURRY\_OVERWORLD & \color{red}= & \color{red}Sound when Mario is almost out of time\\
    \color{red}GAME\_OVER & \color{red}= & \color{red}Sound when Mario loses all his lives\\
    \color{red}STAGE\_CLEAR & \color{red}= & \color{red}Sound when Mario clears a stage\\
    COIN\_SOUND  & = & Sound for collecting a coin\\
    BUMP\_SOUND  & = & Sound when objects are bumped\\
    STOMP\_SOUND & = & Sound when Mario stomps an enemy\\
    JUMP\_SOUND  & = & Sound when Mario jumps\\
    DEATH\_SOUND & = & Sound when Mario dies\\
    \color{red}MUSHROOM\_SOUND & \color{red}= & \color{red}Sound when Mario powers up\\
    \color{red}MUSHROOM\APPEARS & \color{red}= & \color{red}Sound when a mushroom pops out from a box\\
    \color{red}POWER\_DOWN & \color{red}= & \color{red}Sound when Mario loses his powerup from being hit\\
    \color{red}KICK\_SOUND & \color{red}= & \color{red}Sound when Mario kicks a sleeping koopa\\
\end{tabular}
\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Sound\_Controller & --- & Sound\_Controller & ---\\
\hline
play\_sfx             & Sound & ---          & TypeError\\
\hline
sfx\_muted            & ---   & $\mathbb{B}$ & ---\\
\hline
playing\_sfx          & ---   & $\mathbb{B}$ & ---\\
\hline
play\_music           & Sound & ---          & TypeError\\
\hline
music\_muted          & ---   & $\mathbb{B}$ & ---\\
\hline
playing\_music        & ---   & $\mathbb{B}$ & ---\\
\hline
stop\_sfx             & ---   & ---          & ---\\
\hline
mute\_sfx             & ---   & ---          & ---\\
\hline
unmute\_sfx           & ---   & ---          & ---\\
\hline
stop\_music           & ---   & ---          & ---\\
\hline
mute\_music           & ---   & ---          & ---\\
\hline
unmute\_music         & ---   & ---          & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\begin{tabular}{lll}
    music\_ch: Channel         & // & Channel over which music will be played\\ 
    music\_muted: $\mathbb{B}$ & // & Represents whether music can be played\\
    sfx\_ch: Channel           & // & Channel over which sound effects will be played\\
    sfx\_muted: $\mathbb{B}$   & // & Represents whether sound effects can be played
\end{tabular}
\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions \& Design Decisions}
None

\subsubsection* {Access Routine Semantics}

new Sound\_Controller():
\begin{itemize}
\item transition:
    \begin{itemize}[]
        \item sfx\_ch, music\_ch := Channel(0), Channel(1)
        \item sfx\_muted, music\_muted $:= False, False$
    \end{itemize}
\item output: $\mathit{out} := \mathit{self}$
\end{itemize}

\noindent play\_sfx($s$):
\begin{itemize}
\item transition: $\lnot$ sfx\_muted() $\Rightarrow$ play $s$ over the sfx\_ch channel
\item exception: $s$ not of type Sound $\Rightarrow$ TypeError
\end{itemize}

\noindent sfx\_muted():
\begin{itemize}
\item output: $out := $ sfx\_muted
\end{itemize}

\noindent playing\_sfx():
\begin{itemize}
\item output: $out := $ sfx\_ch.get\_busy() // This method returns: $True$ if a sound is playing on the channel, $False$ otherwise.
\end{itemize}

\noindent play\_music(s):
\begin{itemize}
\item transition: $\lnot$ music\_muted() $\Rightarrow$ play $s$ over the music\_ch channel
\item exception: s not of type Sound $\Rightarrow$ TypeError
\end{itemize}

\noindent music\_muted():
\begin{itemize}
\item output: $out := $ music\_muted
\end{itemize}

\noindent playing\_music():
\begin{itemize}
\item output: $out := $ music\_ch.get\_busy()
\end{itemize}

\noindent stop\_sfx():
\begin{itemize}
\item transition: Call sfx\_ch.stop(), which stops any sound playing on the sfx\_ch channel
\end{itemize}

\noindent mute\_sfx():
\begin{itemize}
\item transition: Call stop\_sfx(), then set sfx\_muted := $True$
\end{itemize}

\noindent unmute\_sfx():
\begin{itemize}
\item transition: sfx\_muted := $False$
\end{itemize}

\noindent stop\_music():
\begin{itemize}
\item transition: Call music\_ch.stop()
\end{itemize}

\noindent mute\_music():
\begin{itemize}
\item transition: Call stop\_music(), then set music\_muted := $True$
\end{itemize}

\noindent unmute\_music():
\begin{itemize}
\item transition: music\_muted := $False$
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Spritesheet Module}

\subsection* {Uses}

\begin{tabular}{lll}
    pygame.Rect & & \\
    pygame.Surface & // & Class for representing images\\
    pygame.image & // & Contains methods for loading images from files
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Types}

N/A

\subsubsection* {Exported Constants}

\st{N/A}\\
\textcolor{red}{
SPRITE\_COLLECTION: Dictionary of string to sprite. This contains all the sprites for the game.\\
FONT\_SPRITES: Dictionary of string to sprite. This contains all the sprites related to the font.
}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Spritesheet & string & Spritesheet & ---\\
\hline
image\_at & $\mathbb{N}, \mathbb{N}, \mathbb{R}, (\mathbb{N}, \mathbb{N}, \mathbb{N}), \mathbb{B}, \mathbb{N}, \mathbb{N}$ & Surface & TypeError\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\begin{tabular}{lll}
    sheet: Surface & // & Represents an entire sheet of images in blocks\\ 
\end{tabular}
\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions \& Design Decisions}
None

\subsubsection* {Access Routine Semantics}

new Spritesheet(filename):
\begin{itemize}
\item transition:
    \begin{itemize}[]
        \item sheet := image.load(filename)
        \item After assigning sheet, check if it has an alpha value in the pixels. If it does, then it is converted into a different pixel format while preserving the alpha, else it just converts the image.
    \end{itemize}
\item out: $out := self$
\end{itemize}

\noindent image\_at($x, y, scaling\_factor, color\_key, ignore\_tile\_size, x\_tile\_size, y\_tile\_size$):
\begin{itemize}
\item out: This method creates a rectangle of the appropriate size (Rect($x, y, x\_tile\_size, y\_tile\_size$) or Rect($x \cdot x\_tile\_size, y \cdot y\_tile\_size, x\_tile\_size, y\_tile\_size$)), then creates a surface from this rectangle. It then "cuts out" a portion of sheet of the rectangle size and copies it into the new surface. Lastly, the method returns an image that is scaled by the scaling\_factor.
\end{itemize}


\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Collider Module}

\subsection* {Uses}
Entity\textcolor{red}{Base}\\
Level
\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Collider & Entity\textcolor{red}{Base}, Level & Collider & ---\\
\hline
check\_x & --- & --- & ---\\
\hline
check\_y & --- & --- & ---\\
\hline
right\_level\_border\_reached & --- & $\mathbb{B}$ & ---\\
\hline
left\_level\_border\_reached & --- & $\mathbb{B}$ & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\begin{tabular}{lll}
    entity: Entity\textcolor{red}{Base} & // & Entity to check collision for \\
    level: list & // & list of objects to check for collidable objects \\
    level\_obj: Level & // & The level object itself
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Collider(entity, level):
\begin{itemize}
    \item transition: entity, level\_obj, level := entity, level, level.level
    \item output: $out := self$
\end{itemize}

check\_x():
\begin{itemize}
    \item transition: Checks if entity is colliding with any level objects in the x direction. If so, it sets the entities horizontal velocity to 0, and updates the position of the entity so they are no longer colliding (if colliding on left, set x coordinate so that the objects are no longer intersecting).
\end{itemize}

check\_y():
\begin{itemize}
    \item transition: Checks if entity is colliding with any level objects in the y direction. If so, it sets the entities vertical velocity to 0, and updates the position of the entity so they are no longer colliding (if colliding on top, set y coordinate so that the objects are no longer intersecting).
\end{itemize}

right\_level\_border\_reached():
\begin{itemize}
    \item output: entity.x $>$ level.level\_length $\Rightarrow$ True
\end{itemize}

left\_level\_border\_reached():
\begin{itemize}
    \item output: entity.x $<$ 0 $\Rightarrow$ True
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Animation Module}

\subsection* {Uses}
pygame.Surface
\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Animation & List[Surface], Surface, Surface, $\mathbb{N}$ & Animation & ---\\
\hline
update & --- & --- & ---\\
\hline
idle & --- & --- & ---\\
\hline
in\_air & --- & --- & ---\\
\hline
\color{red}set\_image & \color{red}Surface & \color{red}--- & \color{red}---\\
\hline
\color{red}get\_image & \color{red}--- & \color{red}Surface & \color{red}---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\begin{tabular}{lll}
    images: List[Surface] & // & Contains the images to be part of the animation sequence\\
    timer: $\mathbb{N}$ & // & Keeps track of the time the animation has been going on\\
    index: $\mathbb{N}$ & // & Keeps track of the index of the current frame from images\\
    image: Surface & // & The current image in the animation\\
    idle\_sprite: Surface & // & The default sprite when the animation is stopped\\
    air\_sprite: Surface & // & The default sprite when an entity is in the air\\
    delta\_time: $\mathbb{N}$ & // & The time it takes for the animation to complete a cycle\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Animation(images, idle\_sprite, air\_sprite, delta\_time):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item timer, index := 0, 0
        \item images, image := images, images[index]
        \item idle\_sprite, air\_sprite, delta\_time := idle\_sprite, air\_sprite, delta\_time
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update():
\begin{itemize}
    \item transition:
    \begin{itemize}[]
        \item timer := timer + 1
        \item \begin{tabular}{|l|l|}
        \hline
            timer \% delta\_time = 0 & \begin{tabular}{l}
                index $< |$images$| - 1 \Rightarrow$ index := index + 1 \\
                \hline
                $\lnot$ index $< |$images$| - 1 \Rightarrow$ index := 0\\
            \end{tabular}\\
        \hline
        \end{tabular}
        \item image := images[index]\\
    \end{itemize}
\end{itemize}

idle():
\begin{itemize}
    \item transition: image := idle\_sprite
\end{itemize}

in\_air():
\begin{itemize}
    \item transition: image := air\_sprite
\end{itemize}

\textcolor{red}{set\_image(img):}
\begin{itemize}
    \item \color{red}transition: image := img
\end{itemize}

\textcolor{red}{get\_image():}
\begin{itemize}
    \item \color{red}out: image
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {\st{Sprites Module}}

\subsection* {Uses}
Spritesheet
Animation
pygame.Surface
\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
new sprites & --- & Sprites & ---\\
\hline
load\_sprites & Sequence[string] & Map[string:Surface | Animation] & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\begin{tabular}{lll}
    sprite\_collection: Map[string:Surface | Animation] & // & Contains the name of sprites mapped to their image
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new sprites():
\begin{itemize}
    \item transition: Initialize sprite\_collection by calling load\_sprites with a list of file paths.
    \item output: $out := self$
\end{itemize}

load\_sprites(file\_paths):
\begin{itemize}
    \item transition: Goes through each .json file (defined in file\_paths) and parses them. Creates a Spritesheet object, and using information in the json file, it calls Spritesheet.image\_at(...). It then updates res\_dict, and maps the name from the .json file to the image it gets from Spritesheet.image\_at(...). If the image is part of a sequence of images, then an Animation object is created with the sequence of images instead of a Surface.
    
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section* {\st{Sprite Module}}

\subsection* {Uses}

Animation
pygame.Surface

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new sprite & Surface, $\mathbb{B}$, Animation, $\mathbb{B}$ & Sprite & ---\\
\hline
draw\_sprite & $\mathbb{Z, Z}$, Surface & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
\hline
image: Surface & // & Represents the sprite image\\
\hline
colliding: $\mathbb{B}$ & // & Represents the collision state of the sprite\\
\hline
animation: Animation & // & Represents an animation object, if it is not None\\
\hline
redraw\_background: $\mathbb{B}$ & // & If true, redraw the background before drawing the sprite\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new sprite(image, colliding, animation, redraw\_background):
\begin{itemize}
    \item transition: image, colliding, animation, redraw\_background := image, colliding, animation, redraw\_background
    \item output: $out := self$
\end{itemize}

\noindent draw\_sprite(x, y, screen):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item animation $=$ None $\Rightarrow$ screen.blit(image, 32 * x, 32 * y)
        \item animation $\neq$ None $\Rightarrow$ animation.update, screen.blit(animation.image, 32 * x, 32 * y)
    \end{itemize}
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section* {Menu Module}

\subsection*{Template Module}

Menu(screen, dashboard, level)

\subsection* {Uses}

\sout{animation - spritesheet} \\
dashboard - \textcolor{red}{DASHBOARD} \\
levels \textcolor{red}{- LEVEL, } \\
\textcolor{red}{sound - SOUND\_CONTROLLER, SOUNDTRACK} \\
display - \sout{screen} \textcolor{red}{SCREEN, SPRITE\_COLLECTION, Spritesheet}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new menu & screen, dashboard, level & menu & invalid\_argument\\
\hline
\textcolor{red}{run} & & & \\
\hline
update & & & \\
\hline
draw\_dot & & & \\
\hline
load\_settings & string & & \\
\hline
save\_settings & string & & \\
\hline
draw\_menu & & & \\
\hline
draw\_menu\_background & & & \\
\hline
draw\_settings & & & \\
\hline
choose\_level & & & \\
\hline
draw\_border & $\mathbb{N}$, $\mathbb{N}$, $\mathbb{N}$, $\mathbb{N}$, set of $\mathbb{R}$, $\mathbb{N}$ & & \\
\hline
draw\_level\_chooser & & & \\
\hline
load\_level\_names & & list of strings & \\
\hline
check\_input & & & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\sout{$screen$ : screen // from display module}\\
$start$ : $\mathbb{B}$ \\
$in\_settings$: $\mathbb{B}$ \\
$state$: $\mathbb{N}$ // Represents where in menu user is\\
\sout{$level$: level // from level module}\\
$music$ : $\mathbb{B}$ \\
$sfx$: $\mathbb{B}$ \\
$curr\_selected\_level$ : $\mathbb{N}$ // defaults to first level\\
$level\_names$ : [] \\
$in\_choosing\_level$ : $\mathbb{B}$ \\
\sout{$dashboard$ : dashboard // from dashboard module}\\
$level\_count$ : $\mathbb{N}$ \\
$spritesheet$ : $spritesheet$ from module Spritesheet \\
$menu\_banner$ : obejct from $spritesheet$ \\
$menu\_dot$ : object from $spritesheet$ \\
$menu\_dot2$ : object from $spritesheet$

\subsubsection* {State Invariant}

$spritesheet$ $\neq$ None \\
$|level\_names|$ $\geq$  $current\_selected\_level$


\subsubsection* {Assumptions and Design Decisions}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection *{Access Routine Semantics}

\noindent menu($\mathit{screen, dashboard, level}$):
\begin{itemize}
\item transition:
\begin{itemize}
    \item $screen$ := screen
    \item $start$ : False
    \item $in\_settings$: False
    \item $state$: 0 // Represents where in menu user is
    \item $level$: level // from level module
    \item $music$ : True
    \item $sfx$: True
    \item $current\_selected\_level$ : 0
    \item $level\_names$ : []
    \item $in\_choosing\_level$ : False
    \item $dashboard$ : dashboard
    \item $level\_count$ : 0
    \item $spritesheet$ : Spritesheet("./resources/img/title\_screen.png")
    \item $menu\_banner$ :$spritesheet$.image\_at(0, 60, 2, color\_key=[255, 0, 220], ignore\_tile\_size=True, x\_tile\_size=180, y\_tile\_size=88)
    \item $menu\_dot$ : $spritesheet$.image\_at(0, 150, 2, color\_key=[255, 0, 220], ignore\_tile\_size=True)
    \item $menu\_dot2$ : $spritesheet$.image\_at(20, 150, 2, color\_key=[255, 0, 220], ignore\_tile\_size=True)
    \item load\_settings("./settings.json")
\end{itemize}
\item exception: $exc := (screen \equiv None \lor dashboard \equiv None \lor level \equiv None) \Rightarrow \text{invalid\_argument})$
\end{itemize}

\noindent run():
\begin{itemize}
    \item transition:
    
\begin{tabular}{|l|l|}
\hline
\textcolor{red}{True} & \textcolor{red}{$DASHBOARD.state$ = "menu"} \\
\hline
\textcolor{red}{True} & \textcolor{red}{$DASHVOARD.lives$ = $3$} \\
\hline
\textcolor{red}{True} & \textcolor{red}{$DASHBOARD.update()$}\\
\hline
\textcolor{red}{True} & \textcolor{red}{$SOUND\_CONTROLLER.playmusic(SOUNDTRACK)$}\\
\hline
\textcolor{red}{NOT $start$} & \textcolor{red}{$update()$}\\
\hline
\end{tabular}

\item exception: None
\end{itemize}

\noindent update():
\begin{itemize}
\item transition: first check inputs using $check\_input$ before:

\begin{tabular}{|l|l|}
\hline
$in\_choosing\_level$ \equiv True & exit \\
\hline
$in\_choosing\_level$ \equiv False & $draw\_menu\_background$, update $dashboard$\\
\hline
$in\_choosing\_level$ \equiv False & $draw\_menu$\\
\land $ in\_settings $ \equiv False & \\
\hline
$in\_choosing\_level$ \equiv False & $draw\_settings$\\
\land $ in\_settings $ \equiv True & \\
\hline
\end{tabular}

\item exception: None
\end{itemize}

\noindent draw\_dot():
\begin{itemize}
\item transition: 

\begin{tabular}{|l|l|}
\hline
$state \equiv 0$ & $screen$.blit($menu\_dot$, (145, 273))\\
 & $screen$.blit($menu\_dot2$, (145, 313)) \\
 & $screen$.blit($menu\_dot2$, (145, 353)) \\
\hline
$state \equiv 1$ & $screen$.blit($menu\_dot$, (145, 313)) \\
 & $screen$.blit($menu\_dot2$, (145, 273)) \\
 & $screen$.blit($menu\_dot2$, (145, 353)) \\
\hline
$state \equiv 2$ & $screen$.blit($menu\_dot$, (145, 353)) \\
 & $screen$.blit($menu\_dot2$, (145, 273)) \\
 & $screen$.blit($menu\_dot2$, (145, 313)) \\
\hline
\end{tabular}

\item exception: None
\end{itemize}

\noindent load\_settings(string):
\begin{itemize}
\item transition: open $url$ and use json.load to create required $data$

\begin{tabular}{|p{5cm}|l|}
\hhline{|-|-|}
$data$ \equiv "sound" & $music$ = True, \\
 & $SOUND\_CONTROLLER$.unmute\_music(), \\
 & $SOUND\_CONTROLLER$.play\_music($SOUNDTRACK$)\\
\hhline{|-|-|}
$data$ \neq "sound" & $music$ = False, $SOUND\_CONTROLLER$.mute\_music() \\
\hhline{|-|-|}
$data$ \equiv "sfx" & $sfx$ = True, $SOUND\_CONTROLLER$.unmute\_sfx() \\
\hhline{|-|-|}
$data$ \neq "sfx" & $sfx$ = False, $SOUND\_CONTROLLER$.mute\_sfx() \\
\hhline{|-|-|}
\end{tabular}

\item exception: $IOError \lor OSError \Rightarrow music = False \land sfx = False \land \\ SOUND\_CONTROLLER.mute\_music() \land SOUND\_CONTROLLER.mute\_sfx() \land save\_settings("./settings.json")$
\end{itemize}

\noindent save\_settings(string):
\begin{itemize}
\item transition: create a dictionary for $music$ and $sfx$ before using $json.dump$

\item exception: None
\end{itemize}

\noindent draw\_menu():
\begin{itemize}
\item transition:\\
$draw\_dot()$\\
The options "CHOOSE LEVEL", "SETTINGS", "EXIT" \textcolor{red}{and "HIGH SCORE"} are written on the \sout{dashboard} \textcolor{red}{Menu using $DASHBOARD.draw\_text()$}. \textcolor{red}{The dynamic highscore value is also written below "HIGH SCORE" after the value is read from $highscore.txt$.}

\item exception: None
\end{itemize}

\noindent draw\_menu\_background():
\begin{itemize}
\item transition: \\
$(\forall y : \mathbb{N}|y \in [0..13] : \forall x : (\mathbb{N}|x \in [0..20] : screen.blit(self.level.sprites.spriteCollection.get("sky").image, \\
(x * 32, y * 32)))$

$(\forall y : \mathbb{N}|y \in [13..15] : \forall x : (\mathbb{N}|x \in [0..20] : screen.blit\\
(self.level.sprites.spriteCollection.get("ground").image,
(x * 32, y * 32)))$

Using the function $blit$ from the module screen, the banner, mario and goomba icons and the bushes are placed on the menu background.

\item exception: None
\end{itemize}

\noindent draw\_settings():
\begin{itemize}
\item transition: \\
$draw\_dot()$\\

In the settings menu, writes using the dashboard method $draw\_text$ to write the words "MUSIC", "SFX" and "BACK" as well as:

\begin{tabular}{|l|l|}
\hline
$music \equiv True$ & "ON" \\
\hline
$music \equiv False & "OFF"$ \\
\hline
$sfx \equiv True & "ON"$ \\
\hline
$sfx \equiv False & "OFF"$ \\
\hline
\end{tabular}

\item exception: None

\end{itemize}

\noindent choose\_level():
\begin{itemize}
\item transition: \\
$draw\_menu\_background(False)$ \land $in_choosing_level = True \land level\_names = load\_level\_names() \land draw\_level\_chooser()$

\item exception: None

\end{itemize}

\noindent draw\_level\_chooser():
\begin{itemize}
\item transition: Using data from $load\_level\_names$, each level is titled and drawn as a button in the correct location in the menu.

\item exception: None

\end{itemize}

\noindent load\_level\_names():
\begin{itemize}
\item output: Loads level names from the file in "./resources/levels" and returns them into a list.
\item transition: Updates $level\_count$ to equal the length of the created list.

\item exception: None

\end{itemize}

\noindent check\_input():
\begin{itemize}
\item transition: Uses $pygame.event$ to collect all the user's inputs and place them into $events$, after which the type of event in sequence is funnelled into a state machine using a for statement composed of if statements:

\begin{longtable}{|l|l|}
\hline
$event.type$ \equiv $pygame.QUIT$ & $pygame.quit(), sys.exit()$ \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $in\_choosing\_level = False, in\_settings = False, $\\
$event.key \equiv pygame.K\_ESCAPE$ \land & re-initialize $screen, dashboard, level$ \\
$(in\_choosing\_level \equiv True \lor in\_settings \equiv True$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $pygame.quit(), sys.exit()$\\
$event.key \equiv pygame.K\_ESCAPE$ \land & \\
$(in\_choosing\_level \equiv False \lor in\_settings \equiv False$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $current\_selected\_level -= 3, draw\_level\_chooser$ \\
$event.key \equiv pygame.K\_UP \land $ & \\
$(in\_choosing\_level \equiv True \land $ & \\
$current\_selected\_level > 3 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $state -= 1$\\
$event.key \equiv pygame.K\_UP \land $ & \\
$state > 0 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $current\_selected\_level += 3, draw\_level\_chooser$\\
$event.key \equiv pygame.K\_DOWN \land $ & \\
$(in\_choosing\_level \equiv True \land $ & \\
$current\_selected\_level+3 <= level\_count $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $state += 1$\\
$event.key \equiv pygame.K\_DOWN \land $ & \\
$state < 2 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $current\_selected\_level -= 1, draw\_level\_chooser$\\
$event.key \equiv pygame.K\_LEFT \land $ & \\
$current\_selected\_level > 1 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $current\_selected\_level += 1, draw\_level\_chooser$ \\
$event.key \equiv pygame.K\_RIGHT \land $ & \\
$current\_selected\_level < level\_count $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $in\_choosing\_level = False, dashboard.state = "start",$\\
$event.key \equiv pygame.K\_RETURN \land $ & $dashboard.time =$ \sout{$420$} \textcolor{red}{$400$}, \\
$(in\_choosing\_level \equiv True $ & $level.load\_level(level\_names[$\\
 & $current\_selected\_level-1]),$ \\
 & $dashboard.level\_name = level\_names[$ \\
 & $current\_selected\_level -1].split("Level")[1],$ \\
 & $start = True$, EXIT \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $choose\_level()$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv False \land state \equiv 0 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $in\_settings = True, state = 0$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv False \land state \equiv 1 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $pygame.quit(), sys.exit()$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv False \land state \equiv 2 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $music = False, $ \\
$event.key \equiv pygame.K\_RETURN \land $ & $SOUND\_CONTROLLER.stop\_music()$\\
$(in\_settings \equiv True \land state \equiv 0 $ & \\
$\land music \equiv True$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $music = TRUE, $ \\
$event.key \equiv pygame.K\_RETURN \land $ & $SOUND\_CONTROLLER.play\_music($\\
$(in\_settings \equiv True \land state \equiv 0 $ & $SOUNDTRACK)$\\
$\land music \equiv False$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $save\_settings("./settings.json")$ \\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv True \land state \equiv 0 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $sfx = False, SOUND\_CONTROLLER.mute\_sfx()$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv True \land state \equiv 1 $ & \\
$\land sfx \equiv True$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $sfx = True, SOUND\_CONTROLLER.unmute\_sfx()$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv True \land state \equiv 1 $ & \\
$\land sfx \equiv False$ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $save\_settings("./settings.json")$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv True \land state \equiv 1 $ & \\
\hline
$event.type$ \equiv $pygame.KEYDOWN$ \land & $in\_settings = False$\\
$event.key \equiv pygame.K\_RETURN \land $ & \\
$(in\_settings \equiv True \land state \equiv 2 $ & \\
\hline
\end{longtable}

After the state machine runs through, and if it doesn't exit the method during execution, the display is updated using $pygame.display.update()$.
\item exception: None

\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

\newpage

\section* {Dashboard Module}

\subsection*{Template Module}

dashboard

\subsection {Uses}

display - \sout{screen} \textcolor{red}{SCREEN, FONT\_SPRITES, Spritesheet} \\
Mario

\subsection* {Syntax}

\subsubsection *{Exported Constants}

None

\subsubsection* {Exported Types}

\textcolor{red}{DASHBOARD}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Dashboard & \sout{screen, $\mathbb{N}$} & Dashboard & invalidArgument\\
\hline
\textcolor{red}{reset} & & & \\
\hline
update & & & \\
\hline
draw\_text & string, $\mathbb{N}$, $\mathbb{N}$, $\mathbb{N}$ & & \\
\hline
coin\_string & & string & \\
\hline
point\_string & & string & \\
\hline
time\_string & & string & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection *{State Variables}

$state$ : string \\
\sout{$screen$ : instance of type screen} \\
$level\_name$ : string \\
\textcolor{red}{$earned\_points$ : $\mathbb{N}$} \\
$points$ : $\mathbb{N}$ \\
$coins$ : $\mathbb{N}$ \\
$ticks$ : $\mathbb{N}$ \\
$time$ : $\mathbb{N}$ \\
$lives$: $\mathbb{N}$ \\
\textcolor{red}{$new\_level$: $\mathbb{B}$} \\
\textcolor{red}{$sprite\_sheet$: $Spritesheet$} \\
\textcolor{red}{$mushroom\_life$: $sprite\_sheet.image\_at()$}


\subsubsection* {State Invariant}
\begin{itemize}
    \item $time \leq \st{420}\textcolor{red}{400}$
    \item $coins \geq 0$
    \item $points \geq 0$
    \item $1 \leq lives \leq 3$
\end{itemize}

\subsubsection *{Assumptions and Design Decisions}

None

\subsubsection* {Access Routine Semantics}

\noindent dashboard(screen, size):
\begin{itemize}
    \item transition:
    $state$ = "menu" \\
    \sout{$screen$ = screen} \\
    $level\_name$ = "" //empty string \\
    $points$ = 0 \\
    \textcolor{red}{$earned\_points$ = 0} \\
    $coins$ = 0 \\
    $ticks$ = 0 \\
    $time$ = \sout{420} \textcolor{red}{400} \\
    $lives$ = $3$ \\
    \textcolor{red}{$new\_level$ = False} \\
    \textcolor{red}{$sprite\_sheet$: $Spritesheet.$("./resources/img/title\_screen.png"} \\
    \textcolor{red}{$mushroom\_life$: $sprite\_sheet.image\_at(0, 150, 2, color\_key = [0,0,0], ignore\_tile\_size = True)$}
    \item exception: $exc := $\sout{$screen$} \textcolor{red}{$SCREEN$} $\equiv None \Rightarrow invalidArguemnt$
\end{itemize}

\noindent \textcolor{red}{reset():}
\begin{itemize}
    \item  \textcolor{red}{$state$ = "menu"} \\
    \item \textcolor{red}{$screen$ = screen} \\
    \item \textcolor{red}{$level\_name$ = "" //empty string} \\
    \item \textcolor{red}{$points$ = 0} \\
    \item \textcolor{red}{$earned\_points$ = 0} \\
    \item \textcolor{red}{$coins$ = 0} \\
    \item \textcolor{red}{$ticks$ = 0} \\
    \item \textcolor{red}{$time$ = \textcolor{red}{400} } \\
    \item \textcolor{red}{$lives$ = $3$ } \\
    \textcolor{red}{$new\_level$ = False} \\
\end{itemize}

\noindent update():
\begin{itemize}
    \item transition: Uses the methods $draw\_text$ to write the words "MARIO", "WORLD", "TIME" \textcolor{red}{ and "LIVES"} as well using $coin\_string, point\_string, time\_string$ \textcolor{red}{and the value at $lives$} to write the official values of coin, point \textcolor{red}{,} \sout{and} time \textcolor{red}{and the correct number of lives represented by $mushroom\_life$}. The official value of time is only written when $state \neq$ "menu". Lastly, this method also updates the time value:

    \begin{tabular}{|l|l|}
    \hline
    $True$ & $ticks += $\sout{$1$} \textcolor{red}{$2$} \\
    \hline
    $ticks$ \equiv 60 & $ticks$ = 0, $time -= 1$ \\
    \hline
    \end{tabular}
    
    \item exception: None
\end{itemize}

\noindent draw\_text(text, x, y, size):
\begin{itemize}
    \item transition: $(\forall char \in text : char\_sprite = pygame.transform.scale(FONT\_SPRITES[char], (size, size)) \land screen.blit(char\_sprite, (x,y)) \land $
    \begin{tabular}{|l|l|}
    \hline
    $char \equiv$ " " & $x += size//2$ \\
    \hline
    $char \neq $ " " & $x += size$ \\
    \hline
    \end{tabular}
    )
    
    \item exception: None
\end{itemize}

\noindent coin\_string():
\begin{itemize}
    \item output: "\{:02d\}".format($coins$)
    
    \item exception: None
\end{itemize}

\noindent point\_string():
\begin{itemize}
    \item output: "\{:06d\}".format($points$)
    
    \item exception: None
\end{itemize}

\noindent time\_string():
\begin{itemize}
    \item output: "\{:03d\}".format($time$)
    
    \item exception: None
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

\newpage

\section* {Pause Module}

\subsection*{Template Module}

Pause

\subsection *{Uses}

\sout{animation - spritesheet} \\
dashboard \textcolor{red}{- DASHBOARD}\\
\sout{entity} \\
display - \sout{screen} \textcolor{red}{SCREEN} \\
\sout{menu} \\
\textcolor{red}{pygame} \\
\textcolor{red}{game\_controller}

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Pause & \sout{$screen, entity, dashboard$} \textcolor{red}{game\_controller} & Pause & invalidArgument\\
\hline
\textcolor{red}{run} & & & \\
\hline
update & & & \\
\hline
draw\_dot & & & \\
\hline
check\_input & & & \\
\hline
create\_background\_blur & & & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

\sout{$screen$ : instance of type screen} \\
\sout{$entity$ : instance of type entity} \\
\textcolor{red}{$game\_controller: instance of game\_controller$} \\
\sout{$dashboard$ : instance of type dashboard}\\
$state$ : $\mathbb{N}$ \\
$spritesheet$ : value of $Spritesheet()$ \\
$pause\_srfc$ : value of $GaussianBlur()$ \\
$dot$ : instance of $spritesheet$ \\
$gray\_dot$ : instance of $spritesheet$ \\

\subsubsection* {State Invariant}

\begin{itemize}
    \item $0 \leq state \leq 1$
\end{itemize}

\subsubsection* {Assumptions and Design Decisions}

None

\subsubsection* {Access Routine Semantics}

\noindent pause(screen, entity, dashboard):
\begin{itemize}
    \item transition: 
    \sout{$screen$ : screen} \\
    \sout{$entity$ : entity} \\
    \sout{$dashboard$ : dashboard}\\
    \textcolor{red}{$game\_controller : game\_controller$} \\
    $state$ : 0 \\
    $spritesheet$ : $Spritesheet("./resources/img/title\_screen.png")$ \\
    $pause\_srfc$ : $GaussianBlur().filter(screen, 0, 0, 640, 480)$ \\
    $dot$ : $spritesheet.image\_at(0, 150, 2, color\_key=[255, 0, 220], ignore\_tile\_size=True)$ \\
    $gray\_dot$ : $spritesheet.image\_at(20, 150, 2, color\_key=[255, 0, 220], ignore\_tile\_size=True)$ \\
    
    \item exception: $exc := screen \equiv None \lor entity \equiv None \lor dashboard \equiv None \Rightarrow invalidArgument$
\end{itemize}

\noindent \textcolor{red}{run():}
\begin{itemize}
    \item \textcolor{red}{transition: $Do update() when start \equiv False$}
    \item \textcolor{red}{exception: None}
\end{itemize}

\noindent update():
\begin{itemize}
    \item transition: Creates the pause menu over top of the game play screen using $pause\_srfc$ which blurs the background. The words "PAUSED", "CONTINUE" and "BACK TO MENU" are written on the screen, respectively top to bottom, and dots are placed to determine where the selector is. 
    
    \item exception: None
\end{itemize}

\noindent draw\_dot():
\begin{itemize}
    \item transition:
    
    \begin{tabular}{|l|l|}
    \hline
    $state \equiv 0$ & $grey\_dot$ placed beside lower option, \\
     & $dot$ placed beside upper \\
    \hline
    $state \equiv 1$ \equiv 60 & $grey\_dot$ placed beside upper option, \\
     & $dot$ placed beside upper \\
    \hline
    \end{tabular}
    
    \item exception: None
\end{itemize}

\noindent check\_input():
\begin{itemize}
    \item transition: Uses $pygame.event$ to collect all the user's inputs and place them into $events$, after which the type of event in sequence is funnelled into a state machine using a for statement composed of if statements:
    
    \begin{tabular}{|l|l|}
    \hline
    $event.type \equiv pygame.QUIT$ & $pygame.quit(), sys.exit()$ \\
    \hline
    $event.type \equiv pygame.KEYDOWN \land$ & $entity.pause = False$ \\
    $event.key \equiv pygame.K\_RETURN \land$ & \\
    $state \equiv 0$ &*\\
    \hline
    $event.type \equiv pygame.KEYDOWN \land$ & $entity.restart = True$ \\
    $event.key \equiv pygame.K\_RETURN \land$ & \\
    $state \equiv 1$ & \\
    \hline
    $event.type \equiv pygame.KEYDOWN \land$ & $state -= 1$ \\
    $event.key \equiv pygame.K\_UP \land$ & \\
    $state > 0$ & \\
    \hline
    $event.type \equiv pygame.KEYDOWN \land$ & $state += 1$ \\
    $event.key \equiv pygame.K\_DOWN \land$ & \\
    $state < 1$ & \\
    \hline
    \end{tabular}
    
    \item exception: None
\end{itemize}

\noindent create\_background\_blur():
\begin{itemize}
    \item transition: $pause\_srfc = GaussianBlur().filter($\sout{$self.screen$}\textcolor{red}{$SCREEN$}, $0, 0, 640, 480)$
    
    \item exception: None
\end{itemize}

\subsection* {Local Types}

None

\subsection* {Local Functions}

None

\newpage

\section* {\sout{levels.json Module}}

\subsection*{\sout{Template Module}}

\sout{levels.json}

\subsection* {\sout{Description}}

\sout{This is a document that contains the outlines of where different entities such as ground blocks or item boxes or sky etc. will be placed for a given level. This document is used to create the levels upon level initialization and menu initialization.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\color{red}
\section*{Coin Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    EntityBase & &
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Coin & $\mathbb{Z, Z, R}$ & Coin & ---\\
\hline
update & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
animation: Animation & // & Coin animation
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Coin(x, y, gravity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item Initialize super class EntityBase
        \item animation := Copy of the coin animation object from SPRITE\_COLLECTION
        \item type := "Item"
    \end{itemize}
    \item output: $out := self$
\end{itemize}


\noindent update(camera):
\begin{itemize}
    \item transition: animation.update(), draw the coin to the screen at (self.rect.x + cam.x, self.rect.y)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Item Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    EntityBase & & \\
    Sound\_Controller & &\\
    Vector2D & &
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Item & $\mathbb{Z, Z}$ & Item & ---\\
\hline
spawn\_coin & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
item\_pos: Vector2D & // & Represents the items position \\
item\_vel: Vector2D & // & Represents the items velocity \\
animation: Animation & // & Coin animation \\
sound\_played: $\mathbb{B}$ & // & Flag if the sound for collecting the item has played\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Item(x, y):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item item\_pos, item\_vel := Vector2D(x, y), Vector2D(0, 0)
        \item animation := Copy of the coin item animation object from SPRITE\_COLLECTION
        \item sound\_played := False
    \end{itemize}
    \item output: $out := self$
\end{itemize}


\noindent spawn\_coin(camera):
\begin{itemize}
    \item transition: Play the coin collection sound if sound\_played is False, update the animation. Then, animate the object jumping and falling, as well as the points text.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{RandomBox Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    EntityBase & & \\
    Item & & \\
    Vector2D & &
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new RandomBox & $\mathbb{Z, Z, R}$ & RandomBox & ---\\
\hline
update & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
triggered: $\mathbb{B}$ & // & Represents if the box has been triggered\\
max\_time: $\mathbb{N}$ & // & Represents the max time the box moves after being triggered\\
vel: $\mathbb{Z}$ & // & Represents the vertical velocity of the box\\
item: Item & // & Represents the coin inside the box\\
spawn: $\mathbb{B}$ & // & Flag that keeps track if the coin has already been spawned
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new RandomBox(x, y, gravity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item Initialize the super class EntityBase.
        \item animation := Copy of the random box animation object from SPRITE\_COLLECTION
        \item type, triggered, max\_time := "Block", False, 10
        \item vel, item := 1, Item(self.rect.x, self.rect.y)
    \end{itemize}
    \item output: $out := self$
\end{itemize}


\noindent update(camera):
\begin{itemize}
    \item transition: If the box hasn't been triggered, then just update the animation. If the box is triggered, then set the image of the animation to the empty box image, call item.spawn\_coin(camera), animate the box bouncing, and draw the box. 
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{MushroomItem Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    EntityBase & & \\
    Level & & \\
    LeftRightWalkTrait & & \\
    Sound\_Controller & & \\
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new MushroomItem & $\mathbb{Z, Z}$, Level & MushroomItem & ---\\
\hline
spawn\_mushroom & Camera & --- & ---\\
\hline
update & Camera & --- & ---\\
\hline
draw\_mushroom & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
animation: Animation & // & Animation object holding mushroom images\\
sound\_played: $\mathbb{B}$ & // & Flag for if a sound has been played\\
level: Level & // & Holds the level\\
left\_right\_trait: LeftRightWalkTrait & // & For moving the mushroom\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new MushroomItem(x, y, level):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item Initialize the super class EntityBase.
        \item animation := Copy of the mushroom animation object from SPRITE\_COLLECTION
        \item type, level, alive := "powerup", level, False
        \item left\_right\_trait, sound\_played := None, False
    \end{itemize}
    \item output: $out := self$
\end{itemize}

\noindent spawn\_mushroom(camera):
\begin{itemize}
    \item transition: Play the mushroom appearing sound, if sound\_played is False. Draw the mushroom, set alive := True and initialize the left\_right\_trait := LeftRightWalkTrait(self, level)
\end{itemize}

\noindent update(camera):
\begin{itemize}
    \item transition: If the mushroom hasn't been collected yet, then apply gravity, draw the mushroom and update the left\_right\_trait. Otherwise, set alive := None.
\end{itemize}

\noindent draw\_mushroom(camera):
\begin{itemize}
    \item transition: Draw the mushroom to the screen at (self.rect.x + camera.x, self.rect.y)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{PowerUpBox Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    EntityBase & & \\
    MushroomItem & &
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new PowerUpBox & $\mathbb{Z, Z, R}$ & PowerUpBox & ---\\
\hline
update & Camera & --- & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
triggered: $\mathbb{B}$ & // & Represents if the box has been triggered\\
max\_time: $\mathbb{N}$ & // & Represents the max time the box moves after being triggered\\
vel: $\mathbb{Z}$ & // & Represents the vertical velocity of the box\\
item: Mushroom & // & Represents the mushroom inside the box\\
spawn: $\mathbb{B}$ & // & Flag that keeps track if the mushroom has already been spawned
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new PowerUpBox(x, y, gravity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item Initialize the super class EntityBase.
        \item animation := Copy of the power up box animation object from SPRITE\_COLLECTION
        \item type, triggered, max\_time := "Block", False, 10
        \item vel := 1
    \end{itemize}
    \item output: $out := self$
\end{itemize}


\noindent update(camera):
\begin{itemize}
    \item transition: If the box hasn't been triggered, then just update the animation. If the box is triggered, then set the image of the animation to the empty box image, call item.spawn\_mushroom(camera), animate the box bouncing, and draw the box. 
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{EntityCollider Module}

\subsection* {Uses}

\begin{tabular}{lll}
    pygame.Rect & & \\
\end{tabular}

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new EntityCollider & EntityBase & EntityCollider & ---\\
\hline
check & EntityBase & --- & ---\\
\hline
determine\_side & Rect, Rect & Tuple($\mathbb{B,B}$) & ---\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
\begin{tabular}{lll}
entity: EntityBase & // & The entity that has this collider
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new EntityCollider(entity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item entity := entity
    \end{itemize}
    \item output: $out := self$
\end{itemize}

\noindent check(target):
\begin{itemize}
    \item output: If entity.rect and target.rect collide, return (True, determine\_side(target.rect, entity.rect)), otherwise return (False, False)
\end{itemize}

\noindent determine\_side(rect1, rect2):
\begin{itemize}
    \item output: If rect2 is on top of rect1, return True, otherwise return False
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{BounceTrait Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Vector2D & & \\
    EntityBase & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new BounceTrait & EntityBase & BounceTrait & ---\\
\hline
update & --- & --- & ---\\
\hline
reset & --- & --- & ---\\
\hline
set & --- & --- & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
    vel: $\mathbb{Z}$ & // & Represents the vertical velocity of the entity\\
    jump: $\mathbb{B}$ & // & Boolean for indicating if the entity is jumping or not\\
    entity: EntityBase & // & The entity with this trait
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new BounceTrait(entity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item vel, jump, entity := 5, False, entity
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item jump $\Rightarrow$ (set entities y velocity to 0, subtract vel from entities y velocity, jump := False, entity.in\_air := True)
    \end{itemize}
\end{itemize}

reset():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item entity.in\_air := False
    \end{itemize}
\end{itemize}

set():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item entity.in\_air := True
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{GoTrait Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Animation & & \\
    Camera & & \\
    EntityBase & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new GoTrait & Animation, Camera, EntityBase & GoTrait & ---\\
\hline
update & --- & --- & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
    animation: Animation & // & Animation object of the entity\\
    camera: Camera & // & The camera\\
    entity: EntityBase & // & The entity that has this trait\\
    direction: $\mathbb{Z}$ & // & The direction the entity should move based on user input \\
    heading: $\mathbb{Z}$ & // & The direction the entity is heading\\
    accel\_vel: $\mathbb{R}$ & // & The acceleration of the entity when moving\\
    decel\_vel: $\mathbb{R}$ & // & The deceleration of the entity when stopped moving \\
    max\_vel: $\mathbb{R}$ & // & The max velocity of the entity\\
    boost: $\mathbb{B}$ & // & Indicates whether the entity is boosting or not\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new GoTrait(animation, camera, entity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item animation, camera, entity := animation, camera, entity
        \item direction, heading, boost := 0, 1, False
        \item accel\_vel, decel\_vel, max\_vel := 0.4, 0.25, 3.0
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item If boosting, set the max velocity to 5, and speed up the animation. If the direction is non-zero, then the heading is updated, the velocity is updated, and the animation is updated. Else, the animation is updated, and the velocity is updated.
    \end{itemize}
    \item output: $out := self$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{JumpTrait Module}

\subsection* {Uses}

\begin{tabular}{lll}
    EntityBase & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new JumpTrait & EntityBase & JumpTrait & ---\\
\hline
jump & $\mathbb{B}$ & --- & ---\\
\hline
set & --- & --- & ---\\
\hline
reset & --- & --- & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
    vertical\_speed: $\mathbb{R}$ & // & Represents the vertical speed of the entity\\
    jump\_height: $\mathbb{N}$ & // & Represents the jump height of the entity\\
    initial\_height: $\mathbb{N}$ & // & Represents the initial height of the entity\\
    deceleration\_height: $\mathbb{N}$ & // & Represents the height at which the entity starts to decelerate\\
    entity: EntityBase & // & Represents the entity with this trait\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new JumpTrait(entity):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item vertical\_speed, jump\_height, initial\_height := -12, 120, 384
        \item deceleration\_height := jump\_height - (vertical\_speed * vertical\_speed)/(2 * entity.gravity)
    \end{itemize}
    \item output: $out := self$
\end{itemize}

jump(jumping):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item If jumping is true, the entity is not in air and the vertical velocity of the entity is 0, then set the vertical velocity of the entity to vertical\_speed, set entity.in\_air := True, entity.in\_jump := True, set the initial\_height := entity.rect.y. Then, if the entity is in a jump, check if they have jumped past the deceleration\_height and if so, set entity.in\_jump := False.
    \end{itemize}
\end{itemize}

set():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item entity.in\_air := False
    \end{itemize}
\end{itemize}

reset():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item entity.in\_air := True
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{LeftRightWalkTrait Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Collider & & \\
    EntityBase & & \\
    Level & & \\
    Vector2D & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new LeftRightWalkTrait & EntityBase, Level & LeftRightWalkTrait & ---\\
\hline
update & --- & --- & ---\\
\hline
move\_entity & --- & --- & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
    direction: $\mathbb{Z}$ & // & The direction the entity is walking\\
    entity: EntityBase & // & The entity which has this trait\\
    coll_detection: Collider & // & The object which checks for collision\\
    speed: $\mathbb{Z}$ & // & The horizontal velocity of the entity\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new LeftRightWalkTrait(entity, level):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item direction, speed := -1, 1
        \item entity := entity
        \item coll\_detection := Collider(entity, level)
    \end{itemize}
    \item output: $out := self$
\end{itemize}

update():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item If the horizontal velocity of the entity is 0 (ie. they have hit a barrier), then set direction := -direction. Call entity.vel.set\_x(speed * direction) to set the horizontal velocity of the entity and then call move\_entity.
    \end{itemize}
\end{itemize}

move\_entity():
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item Add entity.vel.get\_y() to entity.rect.y, then check for collision in the vertical direction (ie. call coll\_detection.check\_y()). Add entity.vel.get\_x() to entity.rect.x, then check for collision in the horizontal direction (ie. call coll\_detection.check\_x())
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Tile Module}

\subsection* {Uses}

\begin{tabular}{lll}
    pygame.Rect & & \\
    pygame.Surface & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Tile & pygame.Surface, pygame.Rect & Tile & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
sprite: pygame.Surface & // & The image of the tile\\
rect: pygame.Rect & // & The hitbox of the tile\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Tile(sprite, rect):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item sprite, rect := sprite, rect
    \end{itemize}
    \item output: $out := self$
\end{itemize}
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Game\_Controller Module}

\subsection* {Uses}

\begin{tabular}{lll}
    Mario & & \\
    Dashboard & & \\
    Level & & \\
    MainMenu & & \\
    Sound\_Controller & & \\
    pygame.time.Clock & & \\
\end{tabular}

\subsection* {Syntax}

\subsection* {Semantics}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Game\_Controller & --- & Game\_Controller & ---\\
\hline
run & --- & --- & ---\\
\hline
\end{tabular}

\subsubsection* {State Variables}
\begin{tabular}{lll}
\_\_clock: pygame.time.Clock & // & Clock for maintaining a constant frame rate\\
menu: MainMenu & // & Self explanatory\\
\end{tabular}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

None

\subsubsection* {Access Routine Semantics}

new Game\_Controller(sprite, rect):
\begin{itemize}
    \item transition: 
    \begin{itemize}[]
        \item sprite, rect := sprite, rect
    \end{itemize}
    \item output: $out := self$
\end{itemize}

run():
\begin{itemize}
    \item transition:
    This is the main game loop. In an infinite loop, it will first run the menu. After this, it initializes some flags and a mario object with Mario(0, 0). Then, while mario is not restarting, check if mario has reached the right most border, and if so, add the score for finishing, play sounds, and after some time, switch to the next level, resetting some attributes of the dashboard. If there are no more levels (ie. mario has finished the last level), then record the highscore into highscore.txt. If mario hasn't reached the right border, then check if the time is less than the hurry time (ie. 100 time units), and if True then play the hurry music. All else being false, draw the level, update the entities in the level, update the dashboard and update mario. At the end of the inner while loop update the display, and call \_\_clock.tick(60), where 60 is the max frame rate. At the end of the outer while loop, reset the dashboard with Dashboard.reset(), and set menu.start := False.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end {document}
